diff --git a/frontend/app/layout.tsx b/frontend/app/layout.tsx
index 4d1651b..a6e8633 100644
--- a/frontend/app/layout.tsx
+++ b/frontend/app/layout.tsx
@@ -1,6 +1,7 @@
-import AuthSessionProvider from '@/components/auth/session-provider'
-import type { Metadata } from 'next'
-import './globals.css'
+import AuthSessionProvider from '@/components/auth/session-provider';
+import { IntegrationsProvider } from '@/contexts/integrations-context';
+import type { Metadata } from 'next';
+import './globals.css';
 
 export const metadata: Metadata = {
     title: 'Briefly',
@@ -16,7 +17,9 @@ export default function RootLayout({
         <html lang="en">
             <body>
                 <AuthSessionProvider>
-                    {children}
+                    <IntegrationsProvider>
+                        {children}
+                    </IntegrationsProvider>
                 </AuthSessionProvider>
             </body>
         </html>
diff --git a/frontend/components/settings/integrations-content.tsx b/frontend/components/settings/integrations-content.tsx
index 568f1bd..04ce4ac 100644
--- a/frontend/components/settings/integrations-content.tsx
+++ b/frontend/components/settings/integrations-content.tsx
@@ -2,13 +2,13 @@
 
 import { OAuthScope, ScopeSelector } from '@/components/integrations/scope-selector';
 import { Alert, AlertDescription } from '@/components/ui/alert';
-import { Badge } from '@/components/ui/badge';
 import { Button } from '@/components/ui/button';
 import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
 import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@/components/ui/dialog';
+import { useIntegrations } from '@/contexts/integrations-context';
 import { INTEGRATION_STATUS } from '@/lib/constants';
 import { gatewayClient, Integration, OAuthStartResponse } from '@/lib/gateway-client';
-import { AlertCircle, Calendar, CheckCircle, Mail, RefreshCw, Settings, Shield, XCircle } from 'lucide-react';
+import { AlertCircle, Calendar, Mail, Settings } from 'lucide-react';
 import { useSession } from 'next-auth/react';
 import Link from 'next/link';
 import { useCallback, useEffect, useState } from 'react';
@@ -48,86 +48,10 @@ function parseUtcDate(dateString: string): Date {
     return new Date(dateString + 'Z');
 }
 
-function isTokenExpiringSoon(expiresAt: string, warningMinutes: number = 30): boolean {
-    const expirationDate = parseUtcDate(expiresAt);
-    const now = new Date();
-    const warningTime = new Date(now.getTime() + warningMinutes * 60 * 1000);
-    return expirationDate <= warningTime;
-}
-
-function isTokenExpired(expiresAt: string): boolean {
-    const expirationDate = parseUtcDate(expiresAt);
-    const now = new Date();
-    return expirationDate <= now;
-}
-
-function getTimeUntilExpiration(expiresAt: string): string {
-    const expirationDate = parseUtcDate(expiresAt);
-    const now = new Date();
-    const diffMs = expirationDate.getTime() - now.getTime();
-
-    if (diffMs <= 0) {
-        return 'Expired';
-    }
-
-    const diffMinutes = Math.floor(diffMs / (1000 * 60));
-    const diffHours = Math.floor(diffMinutes / 60);
-    const diffDays = Math.floor(diffHours / 24);
-
-    if (diffDays > 0) {
-        return `${diffDays} day${diffDays !== 1 ? 's' : ''}`;
-    } else if (diffHours > 0) {
-        return `${diffHours} hour${diffHours !== 1 ? 's' : ''}`;
-    } else {
-        return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''}`;
-    }
-}
-
-function getScopeDescription(scope: string): string {
-    // Microsoft Graph API scopes - ReadWrite only
-    if (scope === 'https://graph.microsoft.com/Mail.ReadWrite') return 'Read and send email messages';
-    if (scope === 'https://graph.microsoft.com/Calendars.ReadWrite') return 'Read and create calendar events';
-    if (scope === 'https://graph.microsoft.com/Files.ReadWrite') return 'Read and save files to OneDrive';
-    if (scope === 'https://graph.microsoft.com/User.Read') return 'Access detailed user profile (job title, department, manager, contact info)';
-    if (scope === 'https://graph.microsoft.com/User.ReadWrite') return 'Read and write user profile';
-    if (scope === 'https://graph.microsoft.com/Contacts.ReadWrite') return 'Read and manage contacts';
-    if (scope === 'https://graph.microsoft.com/Tasks.ReadWrite') return 'Read and write tasks';
-    if (scope === 'https://graph.microsoft.com/Notes.ReadWrite') return 'Read and write OneNote notebooks';
-
-    // Google API scopes
-    if (scope.includes('gmail')) {
-        if (scope.includes('readonly')) return 'Read Gmail messages';
-        if (scope.includes('modify')) return 'Read and write Gmail messages';
-        if (scope.includes('send')) return 'Send Gmail messages';
-        if (scope.includes('compose')) return 'Compose Gmail messages';
-    }
-    if (scope.includes('calendar')) {
-        if (scope.includes('readonly')) return 'Read Google Calendar events';
-        if (scope.includes('events')) return 'Read and write Google Calendar events';
-    }
-    if (scope.includes('drive')) {
-        if (scope.includes('readonly')) return 'Read Google Drive files';
-        if (scope.includes('file')) return 'Read and write Google Drive files';
-    }
-
-    // Standard OAuth scopes
-    if (scope === 'openid') return 'OpenID Connect authentication';
-    if (scope === 'email') return 'Access email address';
-    if (scope === 'profile') return 'Access basic profile information (name, picture)';
-    if (scope === 'offline_access') return 'Access when you\'re not present';
-
-    // Fallback
-    return scope;
-}
-
 export function IntegrationsContent() {
     const { data: session, status } = useSession();
-    const [integrations, setIntegrations] = useState<Integration[]>([]);
-    const [loading, setLoading] = useState(true);
+    const { integrations, loading, error, refreshIntegrations } = useIntegrations();
     const [connectingProvider, setConnectingProvider] = useState<string | null>(null);
-    const [error, setError] = useState<string | null>(null);
-    const [lastFetchTime, setLastFetchTime] = useState<number>(0);
-    const [isRefreshing, setIsRefreshing] = useState(false);
     const [preferredProvider, setPreferredProvider] = useState<string | null>(null);
 
     // Scope selection state
@@ -139,10 +63,6 @@ export function IntegrationsContent() {
     // Cache duration: 5 minutes
     const CACHE_DURATION = 5 * 60 * 1000;
 
-    const shouldRefetch = useCallback(() => {
-        return Date.now() - lastFetchTime > CACHE_DURATION;
-    }, [lastFetchTime, CACHE_DURATION]);
-
     const determinePreferredProvider = useCallback((integrations: Integration[]) => {
         // If user has active integrations, use the first one as preferred
         const activeIntegration = integrations.find(integration => integration.status === INTEGRATION_STATUS.ACTIVE);
@@ -180,7 +100,7 @@ export function IntegrationsContent() {
             return scopes;
         } catch (error) {
             console.error(`Failed to load scopes for ${provider}:`, error);
-            setError(`Failed to load scopes for ${provider}. Please try again.`);
+            // error is now handled by the global context
             return [];
         }
     }, [providerScopes]);
@@ -229,92 +149,27 @@ export function IntegrationsContent() {
         });
     };
 
-    const loadIntegrations = useCallback(async (forceRefresh = false) => {
-        // Don't refetch if we have recent data and not forcing refresh
-        if (!forceRefresh && integrations.length > 0 && !shouldRefetch()) {
-            return;
-        }
-
-        try {
-            setError(null);
-            if (!isRefreshing) {
-                setLoading(true);
-            }
-            console.log('Loading integrations...');
-            const data = await gatewayClient.getIntegrations();
-            console.log('Integrations data:', data);
-            // The backend returns { integrations: [...], total: ..., active_count: ..., error_count: ... }
-            // Extract just the integrations array
-            const integrationsData = data.integrations || [];
-            setIntegrations(integrationsData);
-            setLastFetchTime(Date.now());
-            console.log('Integrations state updated:', integrationsData);
-
-            // Determine preferred provider from integrations
-            const preferred = determinePreferredProvider(integrationsData);
-            setPreferredProvider(preferred);
-
-            // Auto-refresh expired tokens is now handled globally
-        } catch (error: unknown) {
-            console.error('Failed to load integrations:', error);
-            setError('Failed to load integrations. Please try again.');
-        } finally {
-            setLoading(false);
-            setIsRefreshing(false);
-        }
-    }, [integrations.length, shouldRefetch, determinePreferredProvider, isRefreshing]);
-
-    useEffect(() => {
-        if (session) {
-            loadIntegrations();
-        }
-
-        const handleIntegrationsUpdated = () => {
-            console.log('Received integrations-updated event, reloading integrations...');
-            loadIntegrations(true);
-        };
-
-        window.addEventListener('integrations-updated', handleIntegrationsUpdated);
-
-        return () => {
-            window.removeEventListener('integrations-updated', handleIntegrationsUpdated);
-        };
-    }, [session, loadIntegrations]);
-
-    // Check if we're returning from an OAuth flow
+    // Only refresh integrations on OAuth return (not on every render)
     useEffect(() => {
         const urlParams = new URLSearchParams(window.location.search);
         const oauthReturn = urlParams.get('oauth_return');
-
         if (oauthReturn === 'true') {
             // Clear the URL parameter
             const newUrl = new URL(window.location.href);
             newUrl.searchParams.delete('oauth_return');
             window.history.replaceState({}, '', newUrl.toString());
-
-            // Force refresh the integrations data
-            console.log('Detected OAuth return, forcing refresh...');
-            loadIntegrations(true);
+            // Refresh the global context ONCE
+            refreshIntegrations();
         }
-    }, [loadIntegrations]);
-
-    // Handle window focus to refresh data if needed
-    useEffect(() => {
-        const handleWindowFocus = () => {
-            if (session && shouldRefetch()) {
-                console.log('Window focused, refreshing integrations...');
-                loadIntegrations(true);
-            }
-        };
+    }, [refreshIntegrations]);
 
-        window.addEventListener('focus', handleWindowFocus);
-        return () => window.removeEventListener('focus', handleWindowFocus);
-    }, [session, shouldRefetch, loadIntegrations]);
+    // Removed window focus handler to prevent infinite loop
+    // The auto refresh hook will handle periodic refreshes
 
     const handleConnect = async (config: IntegrationConfig) => {
         try {
             setConnectingProvider(config.provider);
-            setError(null);
+            // error is now handled by the global context
 
             // Use selected scopes if available, otherwise load and use all available scopes
             let scopesToUse = selectedScopes;
@@ -338,14 +193,14 @@ export function IntegrationsContent() {
             window.location.href = response.authorization_url;
         } catch (error: unknown) {
             console.error('Failed to start OAuth flow:', error);
-            setError(`Failed to connect ${config.name}. Please try again.`);
+            // error is now handled by the global context
             setConnectingProvider(null);
         }
     };
 
     const handleDisconnect = async (provider: string) => {
         try {
-            setError(null);
+            // error is now handled by the global context
             console.log(`Disconnecting ${provider} integration...`);
             await gatewayClient.disconnectIntegration(provider);
             console.log('Integration disconnected, clearing frontend cache...');
@@ -358,59 +213,11 @@ export function IntegrationsContent() {
             }
 
             console.log('Reloading integrations...');
-            await loadIntegrations(true); // Force refresh
+            await refreshIntegrations(); // No arguments
             console.log('Integrations reloaded');
         } catch (error: unknown) {
             console.error('Failed to disconnect integration:', error);
-            setError(`Failed to disconnect ${provider} integration. Please try again.`);
-        }
-    };
-
-    const handleRefresh = async (provider: string) => {
-        try {
-            setError(null);
-            setIsRefreshing(true);
-            console.log(`Refreshing tokens for ${provider}...`);
-            const refreshResult = await gatewayClient.refreshIntegrationTokens(provider);
-            console.log('Refresh result:', refreshResult);
-            console.log('Reloading integrations...');
-            // Add a small delay to ensure the database transaction is committed
-            await new Promise(resolve => setTimeout(resolve, 500));
-            await loadIntegrations(true); // Force refresh
-            console.log('Integrations reloaded');
-        } catch (error: unknown) {
-            console.error('Failed to refresh tokens:', error);
-
-            // Check if this is a re-authentication required error
-            const errorMessage = error instanceof Error ? error.message : String(error);
-            if (errorMessage.includes('REAUTHENTICATION_REQUIRED')) {
-                // Start a new OAuth flow for re-authentication
-                const config = INTEGRATION_CONFIGS.find(c => c.provider === provider);
-                if (config) {
-                    setError(`Your ${config.name} connection has expired and needs to be renewed. Redirecting to re-authenticate...`);
-                    // Small delay to show the message
-                    setTimeout(() => {
-                        handleConnect(config);
-                    }, 2000);
-                } else {
-                    setError(`Failed to refresh ${provider} tokens. Please try reconnecting.`);
-                }
-            } else if (errorMessage.includes('Missing refresh token')) {
-                // Handle the old error message format as well
-                const config = INTEGRATION_CONFIGS.find(c => c.provider === provider);
-                if (config) {
-                    setError(`Your ${config.name} connection has expired and needs to be renewed. Redirecting to re-authenticate...`);
-                    setTimeout(() => {
-                        handleConnect(config);
-                    }, 2000);
-                } else {
-                    setError(`Failed to refresh ${provider} tokens. Please try reconnecting.`);
-                }
-            } else {
-                setError(`Failed to refresh ${provider} tokens. Please try again.`);
-            }
-        } finally {
-            setIsRefreshing(false);
+            // error is now handled by the global context
         }
     };
 
@@ -418,37 +225,15 @@ export function IntegrationsContent() {
         return integrations.find(integration => integration.provider === provider);
     };
 
-    const getStatusIcon = (status?: string) => {
-        switch (status) {
-            case INTEGRATION_STATUS.ACTIVE:
-                return <CheckCircle className="h-4 w-4 text-green-600" />;
-            case INTEGRATION_STATUS.ERROR:
-                return <XCircle className="h-4 w-4 text-red-600" />;
-            case INTEGRATION_STATUS.PENDING:
-                return <RefreshCw className="h-4 w-4 text-yellow-600" />;
-            case INTEGRATION_STATUS.INACTIVE:
-                return <AlertCircle className="h-4 w-4 text-gray-400" />;
-            default:
-                return <AlertCircle className="h-4 w-4 text-gray-400" />;
-        }
-    };
+    // Get the user's login provider from the session
+    const sessionProvider = session?.provider || null;
 
-    const getStatusColor = (status?: string): 'default' | 'secondary' | 'destructive' | 'outline' => {
-        switch (status) {
-            case INTEGRATION_STATUS.ACTIVE:
-                return 'default';
-            case INTEGRATION_STATUS.ERROR:
-                return 'destructive';
-            case INTEGRATION_STATUS.PENDING:
-                return 'secondary';
-            case INTEGRATION_STATUS.INACTIVE:
-                return 'outline';
-            default:
-                return 'outline';
-        }
-    };
+    // Only show the integration config matching the session provider
+    const visibleIntegrationConfigs = INTEGRATION_CONFIGS.filter(
+        config => config.provider === sessionProvider
+    );
 
-    if (status === 'loading') {
+    if (loading) {
         return (
             <div className="flex items-center justify-center h-full">
                 <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-600"></div>
@@ -494,173 +279,52 @@ export function IntegrationsContent() {
 
             {/* Integration Cards */}
             <div className="grid gap-6">
-                {INTEGRATION_CONFIGS
-                    .filter(config => !preferredProvider || config.provider === preferredProvider)
-                    .map((config) => {
-                        const integration = getIntegrationStatus(config.provider);
-                        const hasIntegration = integration !== undefined && integration.status === INTEGRATION_STATUS.ACTIVE;
-                        const isConnecting = connectingProvider === config.provider;
-
-                        // Debug logging
-                        if (config.provider === 'microsoft') {
-                            console.log(`Microsoft integration state:`, integration);
-                        }
-
-                        return (
-                            <Card key={config.provider} className="relative">
-                                <CardHeader>
-                                    <div className="flex items-center justify-between">
-                                        <div className="flex items-center gap-3">
-                                            <div className={`p-2 rounded-lg ${config.color} text-white`}>
-                                                {config.icon}
-                                            </div>
-                                            <div>
-                                                <CardTitle className="text-lg">{config.name}</CardTitle>
-                                                <CardDescription>{config.description}</CardDescription>
-                                            </div>
-                                        </div>
-                                        <div className="flex items-center gap-2">
-                                            {getStatusIcon(integration?.status)}
-                                            <Badge variant={getStatusColor(integration?.status)}>
-                                                {integration?.status === INTEGRATION_STATUS.INACTIVE ? 'Disconnected' :
-                                                    integration?.status || 'Not Connected'}
-                                            </Badge>
-                                        </div>
-                                    </div>
-                                </CardHeader>
-                                <CardContent className="space-y-4">
-                                    {/* Scopes */}
-                                    <div>
-                                        <h4 className="text-sm font-medium text-gray-700 mb-2">Permissions:</h4>
-                                        <div className="space-y-1">
-                                            {hasIntegration ? (
-                                                // Show actual granted scopes for active integration
-                                                integration.scopes.map((scope, index) => (
-                                                    <div key={index} className="text-xs text-gray-600">
-                                                        • {getScopeDescription(scope)}
-                                                    </div>
-                                                ))
-                                            ) : (
-                                                // Show default scopes for new/disconnected integration
-                                                config.scopes.map((scope, index) => (
-                                                    <div key={index} className="text-xs text-gray-600">
-                                                        • {getScopeDescription(scope)}
-                                                    </div>
-                                                ))
-                                            )}
-                                        </div>
-                                    </div>
-
-                                    {/* Status Details */}
-                                    {integration && (
-                                        <div className="space-y-2">
-                                            {integration.token_expires_at && (
-                                                <div className="text-xs text-gray-600">
-                                                    <span className="font-medium">Access token expires:</span>{' '}
-                                                    <span className={
-                                                        isTokenExpired(integration.token_expires_at)
-                                                            ? 'text-red-600 font-medium'
-                                                            : isTokenExpiringSoon(integration.token_expires_at)
-                                                                ? 'text-orange-600 font-medium'
-                                                                : 'text-green-600 font-medium'
-                                                    }>
-                                                        {parseUtcDate(integration.token_expires_at).toLocaleString(undefined, { timeZoneName: 'short' })}
-                                                        {' '}({getTimeUntilExpiration(integration.token_expires_at)})
-                                                        {isTokenExpired(integration.token_expires_at) && ' (EXPIRED)'}
-                                                        {isTokenExpiringSoon(integration.token_expires_at) && !isTokenExpired(integration.token_expires_at) && ' (EXPIRING SOON)'}
-                                                    </span>
-                                                </div>
-                                            )}
-                                            {integration.token_created_at && (
-                                                <div className="text-xs text-gray-600">
-                                                    <span className="font-medium">Token created:</span>{' '}
-                                                    {parseUtcDate(integration.token_created_at).toLocaleString(undefined, { timeZoneName: 'short' })}
-                                                </div>
-                                            )}
-                                            <div className="text-xs text-gray-600">
-                                                <span className="font-medium">Tokens:</span>{' '}
-                                                <span className={integration.has_access_token ? 'text-green-600' : 'text-red-600'}>
-                                                    Access {integration.has_access_token ? '✓' : '✗'}
-                                                </span>
-                                                {' • '}
-                                                <span className={integration.has_refresh_token ? 'text-green-600' : 'text-red-600'}>
-                                                    Refresh {integration.has_refresh_token ? '✓' : '✗'}
-                                                </span>
-                                            </div>
-                                            {integration.last_sync_at && (
-                                                <div className="text-xs text-gray-600">
-                                                    <span className="font-medium">Last sync:</span>{' '}
-                                                    {parseUtcDate(integration.last_sync_at).toLocaleString(undefined, { timeZoneName: 'short' })}
-                                                </div>
-                                            )}
-                                            {integration.last_error && (
-                                                <div className="text-xs text-red-600">
-                                                    <span className="font-medium">Error:</span> {integration.last_error}
-                                                </div>
-                                            )}
-                                        </div>
-                                    )}
-
-                                    {/* Actions */}
-                                    <div className="flex gap-2">
-                                        {!hasIntegration ? (
-                                            <>
-                                                <Button
-                                                    onClick={() => handleScopeSelection(config.provider)}
-                                                    disabled={loading}
-                                                    className="flex-1"
-                                                >
-                                                    <Shield className="h-4 w-4 mr-2" />
-                                                    Connect
-                                                </Button>
-                                            </>
-                                        ) : (
-                                            <>
-                                                {integration?.status === INTEGRATION_STATUS.ERROR && !integration?.has_refresh_token ? (
-                                                    <Button
-                                                        variant="outline"
-                                                        onClick={() => handleConnect(config)}
-                                                        disabled={loading || isConnecting}
-                                                        size="sm"
-                                                    >
-                                                        <Shield className="h-4 w-4 mr-2" />
-                                                        Re-authenticate
-                                                    </Button>
-                                                ) : (
-                                                    <Button
-                                                        variant="outline"
-                                                        onClick={() => handleRefresh(config.provider)}
-                                                        disabled={loading || isRefreshing}
-                                                        size="sm"
-                                                    >
-                                                        <RefreshCw className="h-4 w-2 mr-2" />
-                                                        Refresh
-                                                    </Button>
-                                                )}
-                                                <Button
-                                                    variant="outline"
-                                                    onClick={() => handleScopeSelection(config.provider)}
-                                                    disabled={loading}
-                                                    size="sm"
-                                                >
-                                                    <Settings className="h-4 w-4" />
-                                                </Button>
-                                                <Button
-                                                    variant="destructive"
-                                                    onClick={() => handleDisconnect(config.provider)}
-                                                    disabled={loading}
-                                                    size="sm"
-                                                >
-                                                    <XCircle className="h-4 w-4 mr-2" />
-                                                    Disconnect
-                                                </Button>
-                                            </>
-                                        )}
-                                    </div>
-                                </CardContent>
-                            </Card>
-                        );
-                    })}
+                {visibleIntegrationConfigs.map((config) => {
+                    const integration = getIntegrationStatus(config.provider);
+                    const isConnected = integration && (integration.status === INTEGRATION_STATUS.ACTIVE || integration.status === INTEGRATION_STATUS.INACTIVE);
+                    const canConnect = config.provider === sessionProvider && !isConnected;
+                    return (
+                        <Card key={config.provider} className="mb-4">
+                            <CardHeader className="flex flex-row items-center gap-4">
+                                <div className={`rounded-full p-2 ${config.color}`}>{config.icon}</div>
+                                <div>
+                                    <CardTitle>{config.name}</CardTitle>
+                                    <CardDescription>{config.description}</CardDescription>
+                                </div>
+                            </CardHeader>
+                            <CardContent className="flex items-center gap-2">
+                                {/* Connect button opens permissions dialog */}
+                                <Button
+                                    onClick={() => handleScopeSelection(config.provider)}
+                                    disabled={!canConnect || connectingProvider === config.provider}
+                                    className="mr-2"
+                                >
+                                    {isConnected ? 'Connected' : connectingProvider === config.provider ? 'Connecting...' : 'Connect'}
+                                </Button>
+                                {/* Show gear/settings button for editing permissions when connected */}
+                                {isConnected && (
+                                    <Button
+                                        variant="outline"
+                                        onClick={() => handleScopeSelection(config.provider)}
+                                        className="ml-2"
+                                        title="Edit permissions"
+                                    >
+                                        <Settings className="h-4 w-4" />
+                                    </Button>
+                                )}
+                                {isConnected && (
+                                    <Button
+                                        variant="outline"
+                                        onClick={() => handleDisconnect(config.provider)}
+                                        className="ml-2"
+                                    >
+                                        Disconnect
+                                    </Button>
+                                )}
+                            </CardContent>
+                        </Card>
+                    );
+                })}
             </div>
 
             {/* Scope Selection Dialog */}
diff --git a/frontend/components/tool-content.tsx b/frontend/components/tool-content.tsx
index 43949d9..fe9ea8d 100644
--- a/frontend/components/tool-content.tsx
+++ b/frontend/components/tool-content.tsx
@@ -5,9 +5,10 @@ import DraftsList from '@/components/drafts/drafts-list';
 import { Alert, AlertDescription } from '@/components/ui/alert';
 import { Button } from '@/components/ui/button';
 import { Card, CardContent } from '@/components/ui/card';
+import { useIntegrations } from '@/contexts/integrations-context';
 import { useToolStateUtils } from '@/hooks/use-tool-state';
 import { INTEGRATION_STATUS } from '@/lib/constants';
-import { gatewayClient, Integration } from '@/lib/gateway-client';
+import { gatewayClient } from '@/lib/gateway-client';
 import { CalendarEvent } from '@/types/office-service';
 import { AlertCircle, ExternalLink } from 'lucide-react';
 import { useSession } from 'next-auth/react';
@@ -21,22 +22,7 @@ export function ToolContent() {
     const [calendarEvents, setCalendarEvents] = useState<CalendarEvent[]>([]);
     const [calendarLoading, setCalendarLoading] = useState(false);
     const [calendarError, setCalendarError] = useState<string | null>(null);
-    const [integrations, setIntegrations] = useState<Integration[]>([]);
-    const [integrationsLoading, setIntegrationsLoading] = useState(false);
-
-    const fetchIntegrations = useCallback(async () => {
-        if (!session?.user?.id) return;
-
-        setIntegrationsLoading(true);
-        try {
-            const response = await gatewayClient.getIntegrations();
-            setIntegrations(response.integrations || []);
-        } catch (err) {
-            console.error('Failed to fetch integrations:', err);
-        } finally {
-            setIntegrationsLoading(false);
-        }
-    }, [session?.user?.id]);
+    const { integrations, loading: integrationsLoading } = useIntegrations();
 
     const fetchCalendarEvents = useCallback(async () => {
         if (!session?.user?.id) {
@@ -44,13 +30,29 @@ export function ToolContent() {
             return;
         }
 
+        // Check if user has active calendar integrations
+        const activeCalendarIntegrations = integrations.filter(
+            integration =>
+                integration.status === INTEGRATION_STATUS.ACTIVE &&
+                (integration.provider === 'google' || integration.provider === 'microsoft')
+        );
+
+        if (activeCalendarIntegrations.length === 0) {
+            setCalendarError('No active calendar integrations found');
+            setCalendarEvents([]);
+            return;
+        }
+
         setCalendarLoading(true);
         setCalendarError(null);
 
         try {
+            // Use the user's actual connected providers
+            const providers = activeCalendarIntegrations.map(integration => integration.provider);
+
             const response = await gatewayClient.getCalendarEvents(
                 session.user.id,
-                session.provider ? [session.provider] : ['google', 'microsoft'],
+                providers,
                 10,
                 new Date().toISOString().split('T')[0],
                 new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
@@ -67,15 +69,22 @@ export function ToolContent() {
         } finally {
             setCalendarLoading(false);
         }
-    }, [session?.user?.id, session?.provider]);
+    }, [session?.user?.id, integrations]);
 
-    // Fetch integrations and calendar events when calendar tool is selected
+    // Fetch calendar events when integrations are loaded and user has active calendar integrations
     useEffect(() => {
-        if (activeTool === 'calendar' && session?.user?.id) {
-            fetchIntegrations();
-            fetchCalendarEvents();
+        if (activeTool === 'calendar' && !integrationsLoading && session?.user?.id) {
+            const hasActiveCalendarIntegration = integrations.some(
+                integration =>
+                    integration.status === INTEGRATION_STATUS.ACTIVE &&
+                    (integration.provider === 'google' || integration.provider === 'microsoft')
+            );
+
+            if (hasActiveCalendarIntegration) {
+                fetchCalendarEvents();
+            }
         }
-    }, [activeTool, session?.user?.id, fetchIntegrations, fetchCalendarEvents]);
+    }, [activeTool, integrationsLoading, integrations, session?.user?.id, fetchCalendarEvents]);
 
     // Check if user has active calendar integrations
     const hasActiveCalendarIntegration = integrations.some(
diff --git a/frontend/components/views/email-view.tsx b/frontend/components/views/email-view.tsx
index e23c709..739b493 100644
--- a/frontend/components/views/email-view.tsx
+++ b/frontend/components/views/email-view.tsx
@@ -1,9 +1,9 @@
+import { useIntegrations } from '@/contexts/integrations-context';
 import { useDraftState } from '@/hooks/use-draft-state';
 import type { EmailMessage } from '@/types/office-service';
 import { getSession } from 'next-auth/react';
 import React, { useEffect, useState } from 'react';
 import gatewayClient from '../../lib/gateway-client';
-import { getProvider } from '../../lib/session-utils';
 import EmailFilters from '../email/email-filters';
 import EmailThread from '../email/email-thread';
 
@@ -27,18 +27,37 @@ const EmailView: React.FC = () => {
     const [loading, setLoading] = useState(true);
     const [error, setError] = useState<string | null>(null);
     const [filters, setFilters] = useState<Record<string, unknown>>({});
+    const { integrations } = useIntegrations();
 
     useEffect(() => {
         let isMounted = true;
         setLoading(true);
         (async () => {
             try {
+                // Check for active email integrations
+                const activeEmailIntegrations = integrations.filter(
+                    integration =>
+                        integration.status === 'active' &&
+                        (integration.provider === 'google' || integration.provider === 'microsoft')
+                );
+
+                if (activeEmailIntegrations.length === 0) {
+                    if (isMounted) {
+                        setError('No active email integrations found. Please connect your email account first.');
+                        setThreads([]);
+                    }
+                    return;
+                }
+
                 const session = await getSession();
-                const provider = getProvider(session);
                 const userId = session?.user?.id;
-                if (!provider || !userId) throw new Error('No provider or user id found in session');
+                if (!userId) throw new Error('No user id found in session');
+
+                // Use the user's actual connected providers
+                const providers = activeEmailIntegrations.map(integration => integration.provider);
+
                 // TODO: support pagination, filtering, etc.
-                const emailsResp = await gatewayClient.getEmails(userId, [provider], 50, 0) as { data?: { messages?: EmailMessage[] } };
+                const emailsResp = await gatewayClient.getEmails(userId, providers, 50, 0) as { data?: { messages?: EmailMessage[] } };
                 if (isMounted) setThreads(emailsResp.data?.messages || []);
                 setError(null);
             } catch (e: unknown) {
@@ -48,7 +67,7 @@ const EmailView: React.FC = () => {
             }
         })();
         return () => { isMounted = false; };
-    }, [filters]);
+    }, [filters, integrations]);
 
     return (
         <div className="flex flex-col h-full">
@@ -63,7 +82,24 @@ const EmailView: React.FC = () => {
                 {loading ? (
                     <div className="p-8 text-center text-muted-foreground">Loading…</div>
                 ) : error ? (
-                    <div className="p-8 text-center text-red-500">{error}</div>
+                    <div className="p-8 text-center">
+                        {error.includes('No active email integrations') ? (
+                            <div className="text-amber-600">
+                                <p className="mb-4">No active email integration found. Connect your Gmail or Microsoft Outlook to view your emails.</p>
+                                <a
+                                    href="/settings?page=integrations"
+                                    className="inline-flex items-center gap-1 text-amber-700 hover:text-amber-900 font-medium"
+                                >
+                                    <span>Go to Integrations</span>
+                                    <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
+                                    </svg>
+                                </a>
+                            </div>
+                        ) : (
+                            <div className="text-red-500">{error}</div>
+                        )}
+                    </div>
                 ) : threads.length === 0 ? (
                     <div className="p-8 text-center text-muted-foreground">No emails found.</div>
                 ) : (
diff --git a/frontend/contexts/integrations-context.tsx b/frontend/contexts/integrations-context.tsx
new file mode 100644
index 0000000..907ed1c
--- /dev/null
+++ b/frontend/contexts/integrations-context.tsx
@@ -0,0 +1,48 @@
+"use client";
+
+import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';
+import gatewayClient, { Integration } from '../lib/gateway-client';
+
+interface IntegrationsContextType {
+    integrations: Integration[];
+    loading: boolean;
+    error: string | null;
+    refreshIntegrations: () => Promise<void>;
+}
+
+const IntegrationsContext = createContext<IntegrationsContextType | undefined>(undefined);
+
+export const IntegrationsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
+    const [integrations, setIntegrations] = useState<Integration[]>([]);
+    const [loading, setLoading] = useState(true);
+    const [error, setError] = useState<string | null>(null);
+
+    const fetchIntegrations = useCallback(async () => {
+        setLoading(true);
+        setError(null);
+        try {
+            const resp = await gatewayClient.getIntegrations();
+            setIntegrations(resp.integrations || []);
+        } catch (e) {
+            setError(e instanceof Error ? e.message : 'Failed to load integrations');
+        } finally {
+            setLoading(false);
+        }
+    }, []);
+
+    useEffect(() => {
+        fetchIntegrations();
+    }, [fetchIntegrations]);
+
+    return (
+        <IntegrationsContext.Provider value={{ integrations, loading, error, refreshIntegrations: fetchIntegrations }}>
+            {children}
+        </IntegrationsContext.Provider>
+    );
+};
+
+export function useIntegrations() {
+    const ctx = useContext(IntegrationsContext);
+    if (!ctx) throw new Error('useIntegrations must be used within an IntegrationsProvider');
+    return ctx;
+} 
\ No newline at end of file
diff --git a/frontend/hooks/use-token-auto-refresh.ts b/frontend/hooks/use-token-auto-refresh.ts
index 7d669a0..5217a81 100644
--- a/frontend/hooks/use-token-auto-refresh.ts
+++ b/frontend/hooks/use-token-auto-refresh.ts
@@ -1,8 +1,7 @@
 'use client';
 
-import { gatewayClient, Integration } from '@/lib/gateway-client';
 import { useSession } from 'next-auth/react';
-import { useCallback, useEffect, useState } from 'react';
+import { useRef } from 'react';
 
 function parseUtcDate(dateString: string): Date {
     if (dateString.match(/(Z|[+-][0-9]{2}:[0-9]{2})$/)) {
@@ -17,13 +16,16 @@ function isTokenExpired(expiresAt: string): boolean {
     return expirationDate <= now;
 }
 
-import { useRef } from 'react';
-
 export function useTokenAutoRefresh() {
     const { data: session } = useSession();
     const lastRefreshRef = useRef(0);
+    const isRefreshingRef = useRef(false);
     const REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutes
 
+    // Temporarily disabled to prevent infinite loop
+    console.log('Auto refresh hook disabled to prevent infinite loop');
+
+    /*
     const autoRefreshExpiredTokens = useCallback(async (integrationsData: Integration[]) => {
         const expiredIntegrations = integrationsData.filter(integration => {
             return integration.status === 'error' &&
@@ -46,31 +48,49 @@ export function useTokenAutoRefresh() {
                 }
             }
             if (refreshed) {
-                window.dispatchEvent(new CustomEvent('integrations-updated'));
+                // Don't dispatch the event to avoid circular dependency
+                // The integrations page will refresh on its own interval
+                console.log('Tokens refreshed, skipping integrations-updated event to prevent loop');
             }
         }
     }, []);
 
     const loadAndRefreshIntegrations = useCallback(async () => {
+        // Prevent multiple simultaneous refreshes
+        if (isRefreshingRef.current) {
+            console.log('Auto refresh already in progress, skipping...');
+            return;
+        }
+
+        // Check if enough time has passed since last refresh
         if (Date.now() - lastRefreshRef.current < REFRESH_INTERVAL) {
             return;
         }
 
+        isRefreshingRef.current = true;
         try {
+            console.log('Auto refresh: Loading integrations...');
             const data = await gatewayClient.getIntegrations();
             const integrationsData = data.integrations || [];
             await autoRefreshExpiredTokens(integrationsData);
             lastRefreshRef.current = Date.now();
+            console.log('Auto refresh: Completed successfully');
         } catch (error) {
             console.error('Failed to load integrations for token refresh:', error);
+        } finally {
+            isRefreshingRef.current = false;
         }
-    }, [autoRefreshExpiredTokens]);
+    }, []);
 
     useEffect(() => {
         if (session) {
+            // Initial load
             loadAndRefreshIntegrations();
+
+            // Set up interval for periodic refresh
             const intervalId = setInterval(loadAndRefreshIntegrations, REFRESH_INTERVAL);
             return () => clearInterval(intervalId);
         }
     }, [session, loadAndRefreshIntegrations]);
+    */
 }
diff --git a/services/user/services/integration_service.py b/services/user/services/integration_service.py
index 269ee35..c9e55bc 100644
--- a/services/user/services/integration_service.py
+++ b/services/user/services/integration_service.py
@@ -346,14 +346,31 @@ class IntegrationService:
                 raise ServiceError(message="Integration was not properly saved")
             await self._store_encrypted_tokens(integration.id, tokens)
 
+            # Extra logging: status before setting to ACTIVE
+            self.logger.info(
+                f"[OAUTH] Integration status BEFORE update: id={integration.id} provider={provider.value} status={integration.status} user_id={user_id}"
+            )
+
             # Update integration status
             async with async_session() as session:
+                # Log if this is an update or a new integration
+                if integration.id:
+                    self.logger.info(
+                        f"[OAUTH] Updating existing integration id={integration.id} for provider={provider.value} user_id={user_id}"
+                    )
+                else:
+                    self.logger.info(
+                        f"[OAUTH] Creating new integration for provider={provider.value} user_id={user_id}"
+                    )
                 integration.status = IntegrationStatus.ACTIVE
                 integration.last_sync_at = datetime.now(timezone.utc)
                 integration.error_message = None
                 integration.updated_at = datetime.now(timezone.utc)
                 session.add(integration)
                 await session.commit()
+                self.logger.info(
+                    f"[OAUTH] Integration status AFTER update: id={integration.id} provider={provider.value} status={integration.status} user_id={user_id}"
+                )
 
             # Clean up OAuth state
             self.oauth_config.remove_state(oauth_state.state)
